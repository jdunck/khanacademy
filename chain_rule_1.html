{% extends "adding_and_subtracting_fractions.html" %}

{% block maincode %}
<script type="text/javascript" src="/javascript/calculus.js?{{App.version}}"></script>
<script language=Javascript1.2><!--
// Chain rule 1

// use the same generators for both inner & outer functions
funcGens = [];

funcGens[0] = function(x) {
    // power rule, polynomials
    var high_deg = getRandomIntRange(2, 6);
    var low_deg = getRandomIntRange(0, 2);
    var coefs = polyCoefs(low_deg, high_deg);
	
	return { fofx: polyExp(low_deg, high_deg, coefs, x),
			dfofx: dPolydx(low_deg, high_deg, coefs, x),
			wrongs: [
				dPolydx_wrong1(low_deg, high_deg, coefs, x),
				dPolydx_wrong2(low_deg, high_deg, coefs, x),
				dPolydx_wrong3(low_deg, high_deg, coefs, x),
				dPolydx_wrong4(low_deg, high_deg, coefs, x),
				dPolydx_wrong5(low_deg, high_deg, coefs, x),
				] };
}

funcGens[1] = function(x) {
	// random trig func
	var idx = getRandomInt(2); // 0 - 2 in trig funcs
	var wrongs = [];
	
	wrongs[0] = 'sin ' + x;
    wrongs[1] = 'csc ' + x;
    wrongs[2] = 'sec ' + x;
    wrongs[3] = 'tan ' + x;
    wrongs[4] = '-sec ' + x;
    wrongs[5] = '-cos ' + x;
	
	return { fofx: trigFuncs[idx] + ' ' + x,
			dfofx: dTrigFuncdx[trigFuncs[idx]] + ' ' + x,
			wrongs: wrongs };
}

funcGens[2] = function(x) {
	// basic x^power, simplified version of polynomials in [0]
	// kept this around mainly for easy wrong answer generation
	var high_deg = getRandomIntRange(2, 6);
    var low_deg = high_deg;
	
    var coefs = [];
	coefs[high_deg] = 1;
	
	return { fofx: polyExp(low_deg, high_deg, coefs, x),
			dfofx: dPolydx(low_deg, high_deg, coefs, x),
			wrongs: [
				dPolydx_wrong1(low_deg, high_deg, coefs, x),
				dPolydx_wrong2(low_deg, high_deg, coefs, x),
				dPolydx_wrong3(low_deg, high_deg, coefs, x),
				dPolydx_wrong4(low_deg, high_deg, coefs, x),
				dPolydx_wrong5(low_deg, high_deg, coefs, x),
				] };
}

funcGens[3] = function(x) {
	// ln x and e^x, combined in one because these should not be too likely
	var wrongs = [];
	
	if (getRandomInt(1)) {
		wrongs[0] = '1/(ln '+x+')';
	    wrongs[1] = 'e^' + x;
	    wrongs[2] = '1/(e^'+ x + ')';
	    wrongs[3] = 'ln '+x;
	    wrongs[4] = '1/('+x+'^2)';
	    wrongs[5] = x;
		
		return { fofx: "ln " + x,
				dfofx: "1/" + x,
				wrongs: wrongs };
	} else {
		wrongs[0] = x + '*e^('+x+'-1)';
	    wrongs[1] = '1/'+ x;
	    wrongs[2] = x+'*e^'+x+'';
	    wrongs[3] = 'e^('+x+'-1)';
	    wrongs[4] = '(e-'+x+')^'+x;
	    wrongs[5] = 'e/' + x;
		
		return { fofx: "e^"+ x,
				dfofx: "e^"+ x,
				wrongs: wrongs };
	}
}
inner = funcGens[getRandomInt(funcGens.length-1)]('x');
// nobody should have to do polynomials as the outer function :D
outer = funcGens[getRandomIntRange(1, funcGens.length-1)]('('+inner.fofx+')');

// this is the real one
// outer.dfofx doesn't include the derivative of the inner function,
// even though outer.fofx contains inner.fofx
derivative = outer.dfofx + '*(' + inner.dfofx + ')';

write_text('`f(x) = ' + outer.fofx + '`');
write_text('`f\'(x) = ?');

write_step('`f\'(x) = (`derivative of `' + outer.fofx + '` with respect to `' + inner.fofx + 
				') * (`derivative of `' + inner.fofx + '` with respect to `x)`');
write_step('The derivative of `' + outer.fofx + '` with respect to `' + inner.fofx + ' = ' + outer.dfofx + '`');
write_step('The derivative of `' + inner.fofx + '` with respect to `x = ' + inner.dfofx + '`');
write_step('So `f\'(x) = ' + derivative + '`');
setCorrectAnswer(derivative);

for (var i = 0; i < 2; i++) {
	addWrongChoice(outer.wrongs[getRandomInt(outer.wrongs.length-1)] + 
					'*(' + inner.wrongs[getRandomInt(inner.wrongs.length-1)] + ')');
}

for (var i = 0; i < 2; i++) {
	addWrongChoice(outer.wrongs[getRandomInt(outer.wrongs.length-1)] + 
					'+(' + inner.wrongs[getRandomInt(inner.wrongs.length-1)] + ')');
}

addWrongChoice(outer.dfofx);
for (var i = 0; i < 2; i++) {
	addWrongChoice(outer.wrongs[getRandomInt(outer.wrongs.length-1)]);
}

//-->
</script>
{% endblock maincode %}

{% block maincell %}
{% endblock maincell %}

{% block maincellwidth %}70%{% endblock maincellwidth %}